[6种算法](https://www.toutiao.com/article/7199435823970828857)
## 递归算法
递归算法是一种直接或者间接调用自身函数或者方法的算法。
递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。递归算法对解决一大类问题很有效，它可以使算法简洁和易于理解。

### 优缺点：
- 优点：实现简单易上手
- 缺点：递归算法对常用的算法如普通循环等，运行效率较低；并且在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归太深，容易发生栈溢出

### 适用场景

递归算法一般用于解决三类问题：
- 数据的定义是按递归定义的。（斐波那契数列）
- 问题解法按递归算法实现。（回溯）
- 数据的结构形式是按递归定义的。（树的遍历，图的搜索）

### 递归的解题策略：

- 第一步：明确你这个函数的输入输出，先不管函数里面的代码什么，而是要先明白，你这个函数的输入是什么，输出为何什么，功能是什么，要完成什么样的一件事。
- 第二步：寻找递归结束条件，我们需要找出什么时候递归结束，之后直接把结果返回
- 第三步：明确递归关系式，怎么通过各种递归调用来组合解决当前问题


## 分治算法
分治算法是一个很重要的算法，快速排序、归并排序等都是基于分治策略进行实现的

### 适用场景
当出现满足以下条件的问题，可以尝试只用分治策略进行求解：

- 原始问题可以分成多个相似的子问题
- 子问题可以很简单的求解
- 原始问题的解是子问题解的合并
- 各个子问题是相互独立的，不包含相同的子问题

  二分查找
  归并排序
  快速排序
  汉诺塔问题
  React 时间分片

### 策略：

1. 分解，将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
2. 解决，解决各个子问题
3. 合并，将各个子问题的解合并为原问题的解


## 贪心算法
贪心算法，故名思义，总是做出当前的最优选择，即期望通过局部的最优选择获得整体的最优选择。
某种意义上说，贪心算法是很贪婪、很目光短浅的，它不从整体考虑，仅仅只关注当前的最大利益，所以说它做出的选择仅仅是某种意义上的局部最优，
但是贪心算法在很多问题上还是能够拿到最优解或较优解，所以它的存在还是有意义的。

### 案例
最小生成树算法
单源最短路径的 Dijkstra 算法
Huffman 压缩编码
背包问题
活动选择问题等


## 回溯算法
回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。

###案例

深度优先搜索
0-1背包问题
正则表达式匹配
八皇后
数独
全排列


## 动态规划

动态规划也是将复杂问题分解成小问题求解的策略，与分治算法不同的是，分治算法要求各子问题是相互独立的，而动态规划各子问题是相互关联的。

所以，动态规划适用于子问题重叠的情况，即不同的子问题具有公共的子子问题，在这种情况下，分治策略会做出很多不必要的工作，它会反复求解那些公共子子问题，
而动态规划会对每个子子问题求解一次，然后保存在表格中，如果遇到一致的问题，从表格中获取既可，所以它无需求解每一个子子问题，避免了大量的不必要操作。


我们使用动态规划求解问题时，需要遵循以下几个重要步骤：

定义子问题
实现需要反复执行解决的子子问题部分
识别并求解出边界条件

### 案例
- 爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
- 背包问题：给出一些资源（有总量及价值），给一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的情况下，装入更多的价值
- 硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种找零方案
- 图的全源最短路径：一个图中包含 u、v 顶点，找出从顶点 u 到顶点 v 的最短路径
- 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变剩下元素的顺序实现）


## 枚举算法
枚举算法的思想是：将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的。
